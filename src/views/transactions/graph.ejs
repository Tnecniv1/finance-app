<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Progression - Ã‰volution - Fidess</title>

  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    .filters-container, .chart-container, .stats-container, .header {
      background: #fff; border-radius: 15px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .header { padding: 20px 30px; margin-bottom: 20px; display:flex; justify-content:space-between; align-items:center; }
    .filters-container { padding: 20px 30px; margin-bottom: 20px; }
    .chart-container { padding: 30px; margin-bottom: 20px; }
    .chart-wrapper { position: relative; height: 650px; }
    .legend-container { display:flex; gap:15px; flex-wrap:wrap; margin-top:25px; padding-top:25px; border-top:2px solid #e5e7eb; }
    .legend-item { display:flex; align-items:center; gap:10px; padding: 8px 12px; background: #f9fafb; border-radius: 8px; }
    .legend-color { width:20px; height:20px; border-radius:6px; border: 2px solid #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
    .legend-label { font-size:15px; color:#374151; font-weight: 500; }
    .filters-row { display:flex; gap:30px; align-items:center; flex-wrap:wrap; }
    .filter-group { display:flex; flex-direction:column; gap:8px; }
    .filter-group label { font-weight:600; color:#333; font-size:14px; }
    .filter-buttons { display:flex; gap:10px; }
    .filter-btn {
      padding:8px 16px; border:2px solid #e0e7ff; background:#fff; border-radius:8px;
      cursor:pointer; font-size:14px; color:#667eea; transition:all .2s; font-weight:500;
    }
    .filter-btn:hover { border-color:#667eea; background:#f5f7ff; }
    .filter-btn.active { background:#667eea; color:#fff; border-color:#667eea; }
  </style>
</head>

<body>
  <%- include('../partials/navbar-simple', { currentPage: 'progression', user: user }) %>
  <%- include('../partials/progression-header', { currentView: currentView, stats: stats }) %>

  <div class="container">
    <!-- Filtres -->
    <div class="filters-container">
      <div class="filters-row">
        <div class="filter-group">
          <label>Mode d'affichage</label>
          <div class="filter-buttons">
            <button id="btnVueNormale" class="filter-btn active">ðŸ“Š Vue Normale</button>
            <button id="btnProjection" class="filter-btn">ðŸ”® Projection Monte Carlo</button>
          </div>
        </div>

        <div class="filter-group">
          <label>PÃ©riode</label>
          <div class="filter-buttons">
            <button class="filter-btn" data-filter="period" data-value="weekly">Hebdomadaire</button>
            <button class="filter-btn active" data-filter="period" data-value="monthly">Mensuel</button>
            <button class="filter-btn" data-filter="period" data-value="yearly">Annuel</button>
          </div>
        </div>

        <div class="filter-group">
          <label>Type</label>
          <div id="type-buttons" class="filter-buttons">
            <button class="filter-btn active" data-filter="type" data-value="profit">Profit</button>
            <button class="filter-btn" data-filter="type" data-value="revenus">Revenus</button>
            <button class="filter-btn" data-filter="type" data-value="depenses">DÃ©penses</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Graphique -->
    <div class="chart-container">
      <div class="chart-wrapper">
        <canvas id="financeChart"></canvas>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
    // âœ… Fonction pour convertir HEX en RGBA
    function hexToRgba(hex, alpha = 1) {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    // DonnÃ©es render cÃ´tÃ© serveur (historique + catÃ©gories)
    const transactions = <%- JSON.stringify(transactions) %>;
    const categoriesRevenus = <%- JSON.stringify(categoriesRevenus) %>;
    const categoriesDepenses = <%- JSON.stringify(categoriesDepenses) %>;

    let chart = null;
    let isProjectionMode = false;

    const currentFilters = { period: 'monthly', type: 'profit' };

    // Utils
    function formatCurrency(amount) {
      return new Intl.NumberFormat('fr-FR', { style: 'currency', currency: 'EUR' }).format(amount);
    }
    function getWeekNumber(date) {
      const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
      const dayNum = d.getUTCDay() || 7;
      d.setUTCDate(d.getUTCDate() + 4 - dayNum);
      const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
      return Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
    }
    function getDateLabels(period) {
      const labels = []; const now = new Date();
      for (let i = 11; i >= 0; i--) {
        const date = new Date(now);
        if (period === 'daily') {
          date.setDate(date.getDate() - i);
          labels.push(date.toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit' }));
        } else if (period === 'weekly') {
          date.setDate(date.getDate() - (i * 7));
          const weekStart = new Date(date);
          weekStart.setDate(date.getDate() - date.getDay() + 1);
          labels.push('S' + getWeekNumber(weekStart));
        } else if (period === 'monthly') {
          date.setMonth(date.getMonth() - i);
          labels.push(date.toLocaleDateString('fr-FR', { month: 'short', year: '2-digit' }));
        } else { // yearly
          date.setFullYear(date.getFullYear() - i);
          labels.push(String(date.getFullYear()));
        }
      }
      return labels;
    }
    function getDateRangeForPoint(index, period) {
      const now = new Date(); const pointIndex = 11 - index; let start, end;
      if (period === 'daily') {
        start = new Date(now); start.setDate(now.getDate() - pointIndex); start.setHours(0,0,0,0);
        end = new Date(start); end.setHours(23,59,59,999);
      } else if (period === 'weekly') {
        start = new Date(now); start.setDate(now.getDate() - (pointIndex * 7));
        start.setDate(start.getDate() - start.getDay() + 1); start.setHours(0,0,0,0);
        end = new Date(start); end.setDate(start.getDate() + 6); end.setHours(23,59,59,999);
      } else if (period === 'monthly') {
        start = new Date(now); start.setMonth(now.getMonth() - pointIndex); start.setDate(1); start.setHours(0,0,0,0);
        end = new Date(start); end.setMonth(start.getMonth() + 1); end.setDate(0); end.setHours(23,59,59,999);
      } else { // yearly
        start = new Date(now); start.setFullYear(now.getFullYear() - pointIndex); start.setMonth(0,1); start.setHours(0,0,0,0);
        end = new Date(start); end.setFullYear(start.getFullYear() + 1); end.setMonth(0,0); end.setHours(23,59,59,999);
      }
      return { start, end };
    }

    // AgrÃ©gation simple (vue normale)
    function processProfitData(labels, period) {
      const revenus = Array(12).fill(0), depenses = Array(12).fill(0);

      transactions.forEach(t => {
        const tDate = new Date(t.date);
        for (let i = 0; i < 12; i++) {
          const { start, end } = getDateRangeForPoint(i, period);
          if (tDate >= start && tDate <= end) {
            if (t.nature === 'revenu') {
              revenus[i] += Number(t.montant);
            } else {
              depenses[i] += Math.abs(Number(t.montant));
            }
          }
        }
      });

      const profit = revenus.map((r, i) => r - depenses[i]);
      return {
        labels,
        datasets: [
          { label:'Revenus',  data: revenus,  borderColor:'#10b981', backgroundColor:'rgba(16,185,129,.10)', borderWidth:2, fill:false, tension:.3 },
          { label:'DÃ©penses', data: depenses, borderColor:'#ef4444', backgroundColor:'rgba(239,68,68,.10)', borderWidth:2, fill:false, tension:.3 },
          { label:'Profit',   data: profit,   borderColor:'#667eea', backgroundColor:'rgba(102,126,234,.10)', borderWidth:2, fill:false, tension:.3 }
        ]
      };
    }

    function processRevenusData(labels, period) {
      const catMap = {}; categoriesRevenus.forEach(c => catMap[c.id] = c.nom);
      const cats = {}; categoriesRevenus.forEach(c => cats[c.id] = Array(12).fill(0));
      transactions.forEach(t => {
        if (t.nature === 'revenu' && t.sous_categorie_revenu?.categorie_revenu_id) {
          const cid = t.sous_categorie_revenu.categorie_revenu_id; const dt = new Date(t.date);
          for (let i = 0; i < 12; i++) {
            const { start, end } = getDateRangeForPoint(i, period);
            if (dt >= start && dt <= end) cats[cid][i] += Number(t.montant);
          }
        }
      });
      
      // âœ… PALETTE ULTRA-CONTRASTÃ‰E avec des couleurs trÃ¨s diffÃ©rentes
      const palette = [
        '#ef4444', // Rouge vif
        '#10b981', // Vert Ã©meraude
        '#3b82f6', // Bleu
        '#f59e0b', // Orange
        '#8b5cf6', // Violet
        '#ec4899', // Rose fuchsia
        '#06b6d4', // Cyan
        '#eab308', // Jaune
        '#14b8a6', // Teal
        '#f97316', // Orange foncÃ©
        '#a855f7', // Violet clair
        '#84cc16'  // Lime vert
      ];
      
      const datasets = Object.keys(cats).map((cid, i) => {
        const color = palette[i % palette.length];
        return {
          label: catMap[cid] || 'Autre',
          data: cats[cid],
          borderColor: color,
          backgroundColor: hexToRgba(color, 0.85), // âœ… 85% d'opacitÃ© - couleurs vives
          borderWidth: 2, // âœ… Bordure visible pour sÃ©parer les zones
          fill: true,
          tension: 0.3,
          stack: 'revenus'
        };
      });
      return { labels, datasets };
    }

    function processDepensesData(labels, period) {
      const catMap = {}; categoriesDepenses.forEach(c => catMap[c.id] = c.nom);
      const cats = {}; categoriesDepenses.forEach(c => cats[c.id] = Array(12).fill(0));
      transactions.forEach(t => {
        if (t.nature === 'depense' && t.sous_categorie_depense?.categorie_depense_id) {
          const cid = t.sous_categorie_depense.categorie_depense_id; const dt = new Date(t.date);
          for (let i = 0; i < 12; i++) {
            const { start, end } = getDateRangeForPoint(i, period);
            if (dt >= start && dt <= end) cats[cid][i] += Math.abs(Number(t.montant));
          }
        }
      });
      
      // âœ… PALETTE PROFESSIONNELLE inspirÃ©e des graphiques business (tons terre et bleus dÃ©saturÃ©s)
      const palette = [
        '#5b9bd5', // Bleu corporatif (comme dans l'exemple)
        '#ed7d31', // Orange terre cuite
        '#a5a5a5', // Gris neutre
        '#ffc000', // Jaune moutarde
        '#70ad47', // Vert olive
        '#4472c4', // Bleu profond dÃ©saturÃ©
        '#c55a11', // Brun orangÃ©
        '#7cafdd', // Bleu clair corporatif
        '#997300', // Ocre
        '#548235', // Vert forÃªt dÃ©saturÃ©
        '#636363', // Gris foncÃ©
        '#f4b183'  // PÃªche clair
      ];
      
      const datasets = Object.keys(cats).map((cid, i) => {
        const color = palette[i % palette.length];
        return {
          label: catMap[cid] || 'Autre',
          data: cats[cid],
          borderColor: color,
          backgroundColor: hexToRgba(color, 0.75), // âœ… 75% d'opacitÃ© - Ã©quilibre parfait
          borderWidth: 2, // âœ… Bordure visible pour sÃ©parer les zones
          fill: true,
          tension: 0.3,
          stack: 'depenses'
        };
      });
      return { labels, datasets };
    }

    function processTransactions() {
      const labels = getDateLabels(currentFilters.period);
      if (currentFilters.type === 'profit') return processProfitData(labels, currentFilters.period);
      if (currentFilters.type === 'revenus') return processRevenusData(labels, currentFilters.period);
      return processDepensesData(labels, currentFilters.period);
    }

    function updateLegend(datasets) {
      const el = document.getElementById('customLegend'); el.innerHTML = '';
      datasets.forEach(ds => {
        const item = document.createElement('div'); item.className = 'legend-item';
        const color = document.createElement('div'); color.className = 'legend-color'; color.style.backgroundColor = ds.borderColor;
        const label = document.createElement('span'); label.className = 'legend-label'; label.textContent = ds.label;
        item.appendChild(color); item.appendChild(label); el.appendChild(item);
      });
    }

    // Vue normale
    function updateChart() {
      if (isProjectionMode) return;
      const chartData = processTransactions();
      if (chart) { chart.destroy(); chart = null; }
      const ctx = document.getElementById('financeChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true, maintainAspectRatio: false,
          interaction: { mode:'index', intersect:false },
          plugins: {
            legend: { display:false },
            tooltip: { 
              mode: 'index',
              intersect: false,
              backgroundColor: 'rgba(0, 0, 0, 0.85)',
              titleFont: { size: 14, weight: 'bold' },
              bodyFont: { size: 13 },
              padding: 12,
              displayColors: true,
              callbacks: { 
                label: (c) => c.dataset.label + ': ' + formatCurrency(c.parsed.y),
                footer: (items) => {
                  if (currentFilters.type !== 'profit') {
                    const total = items.reduce((sum, item) => sum + item.parsed.y, 0);
                    return 'Total: ' + formatCurrency(total);
                  }
                  return '';
                }
              } 
            }
          },
          scales: {
            x: { 
              grid:{ display:false },
              ticks: { font: { size: 12 } }
            },
            y: {
              stacked: currentFilters.type !== 'profit',
              beginAtZero: true,
              grid: { color: 'rgba(0, 0, 0, 0.05)' },
              ticks: { 
                callback: (v)=> formatCurrency(v),
                font: { size: 12 }
              }
            }
          },
          elements: { line: { tension:.3 } }
        }
      });
      updateLegend(chartData.datasets);
    }

    // Projection Monte Carlo
    async function drawProjectionChart() {
      try {
        if (chart) { chart.destroy(); chart = null; }
        isProjectionMode = true;

        const res = await fetch('/api/projection?weeks=12&numSimulations=1000');
        if (!res.ok) throw new Error('Erreur serveur projection');
        const data = await res.json();
        if (!data || !data.success || !data.projection) {
          console.error('Payload invalide:', data);
          throw new Error('Payload invalide');
        }

        const ctx = document.getElementById('financeChart').getContext('2d');
        chart = new Chart(ctx, {
          type: 'line',
          data: data.projection,
          options: {
            responsive:true, maintainAspectRatio:false,
            interaction:{ mode:'index', intersect:false },
            plugins:{
              title:{ display:true, text:'Projection Monte Carlo â€” Solde futur (12 semaines)', font:{ size:18 } },
              legend:{ display:true, position:'bottom' },
              tooltip:{ callbacks:{ label:(c)=> c.dataset.label + ': ' + formatCurrency(c.parsed.y) } }
            },
            scales:{
              y:{ beginAtZero:false, title:{ display:true, text:'Solde (â‚¬)' }, ticks:{ callback:(v)=> formatCurrency(v) } },
              x:{ title:{ display:true, text:'Semaine' } }
            }
          }
        });

        // (Optionnel) log metrics
        if (data.metrics) {
          console.log('--- RÃ©sumÃ© projection ---');
          console.log('Solde actuel :', data.metrics.soldeActuel);
          console.log('Solde mÃ©dian final :', data.metrics.soldeMedianFinal);
          console.log('Risque nÃ©gatif (%) :', data.metrics.risqueNegatif);
        }
      } catch (err) {
        console.error('Erreur drawProjectionChart:', err);
        alert('Impossible de charger la projection Monte Carlo.');
      }
    }

    function destroyProjection() {
      isProjectionMode = false;
      updateChart();
    }

    // Listeners
    document.getElementById('btnProjection')?.addEventListener('click', drawProjectionChart);
    document.getElementById('btnVueNormale')?.addEventListener('click', destroyProjection);

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', function() {
        const filterType = this.dataset.filter; const value = this.dataset.value;
        if (!filterType) return; // ignore boutons de mode
        document.querySelectorAll(`[data-filter="${filterType}"]`).forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        currentFilters[filterType] = value;
        updateChart();
      });
    });

    // Init
    updateChart();
  </script>
</body>
</html>
